{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///external {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack:///./src/ContinuousCategory.js","webpack:///./src/ContinuousToolbox.js","webpack:///./src/ContinuousMetricsFlyout.js","webpack:///./src/ContinuousFlyout.js","webpack:///./src/ContinuousMetrics.js"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","categoryDef","toolbox","super","label","document","createElement","setAttribute","getId","textContent","classList","add","cssConfig_","icon","style","backgroundColor","colour_","isSelected","rowDiv_","dom","addClass","removeClass","aria","setState","State","SELECTED","register","Type","TOOLBOX_ITEM","registrationName","workspace","init","flyout","getFlyout","show","getInitialFlyoutContents_","recordScrollPositions","contents","toolboxItem","contents_","push","kind","text","getName","itemContents","getContents","custom","concat","_oldItem","newItem","target","getCategoryScrollPosition","name_","y","scrollTo","oldItem","category","find","item","isSelectable","getCategoryByName","selectedItem_","shouldDeselectItem_","deselectItem_","shouldSelectItem_","selectItem_","autoClose","getClientRect","getWorkspaceCoordinates","cachedViewMetrics","cachedContentMetrics","scrollMetrics","getScrollMetrics","contentMetrics","getContentMetrics","viewMetrics","getViewMetrics","height","flyout_","calculateBottomPadding","workspaceOptions","scrollPositions","scrollTarget","scrollAnimationFraction","recycleBlocks_","recyclingEnabled_","workspace_","setMetricsManager","targetWorkspace","getToolbox","categoryLabels","buttons_","filter","button","isLabel","getParentToolbox_","getButtonText","position","getPosition","scrollInfo","console","warn","scaledPosition","Math","round","scale","length","selectCategoryByName","metrics","getMetrics","min","scrollHeight","viewHeight","stepScrollAnimation_","currentScrollPos","scrollY","diff","abs","scrollbar","setY","requestAnimationFrame","lastPosition","lastCategoryHeight","xyRatio","setMetrics_","selectCategoryByScrollPosition_","isVisible","targetWorkspaceMetrics","height_","edgeWidth","width_","CORNER_RADIUS","edgeHeight","setBackgroundPath_","x","toolboxPosition","toolboxPosition_","toolboxWidth","viewWidth","absoluteLeft","positionAt_","flyoutDef","emptyRecycleBlocks_","resizeContents","oldBlocks","oldBlock","dispose","blockXml","blockType","getAttribute","blockIdx","findIndex","block","type","curBlock","splice","domToBlock","isEnabled","permanentlyDisabled_","getTopBlocks","blockIsRecyclable_","recycleBlock_","rect","mats_","unbindMouseEvents","removeNode","getPotentialVariableMap","clear","mutationToDom","domToMutation","input","inputList","field","fieldRow","isOptionListDynamic","connection","targetBlock","func","xy","getRelativeToSurfaceXY","moveBy","svgMetrics","getSvgMetrics","toolboxMetrics","getToolboxMetrics","flyoutMetrics","getFlyoutMetrics","width","top","left","scrollX","absoluteTop","METRICS_MANAGER"],"mappings":"CAAA,SAA2CA,EAAMC,GAChD,GAAsB,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,EAAQG,QAAQ,sBAC7B,GAAqB,mBAAXC,QAAyBA,OAAOC,IAC9CD,OAAO,CAAC,gBAAiBJ,OACrB,CACJ,IAAIM,EAAuB,iBAAZL,QAAuBD,EAAQG,QAAQ,iBAAmBH,EAAQD,EAAc,SAC/F,IAAI,IAAIQ,KAAKD,GAAuB,iBAAZL,QAAuBA,QAAUF,GAAMQ,GAAKD,EAAEC,IAPxE,CASGC,MAAM,SAASC,GAClB,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUX,QAGnC,IAAIC,EAASQ,EAAiBE,GAAY,CACzCL,EAAGK,EACHC,GAAG,EACHZ,QAAS,IAUV,OANAa,EAAQF,GAAUG,KAAKb,EAAOD,QAASC,EAAQA,EAAOD,QAASU,GAG/DT,EAAOW,GAAI,EAGJX,EAAOD,QA0Df,OArDAU,EAAoBK,EAAIF,EAGxBH,EAAoBM,EAAIP,EAGxBC,EAAoBO,EAAI,SAASjB,EAASkB,EAAMC,GAC3CT,EAAoBU,EAAEpB,EAASkB,IAClCG,OAAOC,eAAetB,EAASkB,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhET,EAAoBe,EAAI,SAASzB,GACX,oBAAX0B,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAetB,EAAS0B,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAetB,EAAS,aAAc,CAAE4B,OAAO,KAQvDlB,EAAoBmB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQlB,EAAoBkB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAvB,EAAoBe,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOlB,EAAoBO,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRtB,EAAoB0B,EAAI,SAASnC,GAChC,IAAIkB,EAASlB,GAAUA,EAAO8B,WAC7B,WAAwB,OAAO9B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAS,EAAoBO,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRT,EAAoBU,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG5B,EAAoB+B,EAAI,SAIjB/B,EAAoBA,EAAoBgC,EAAI,G,gBClFrDzC,EAAOD,QAAUQ,G;;;;;GCaV,MAAM,UAA2B,kBAKtC,YAAYmC,EAAaC,GACvBC,MAAMF,EAAaC,GAIrB,gBAAgB1B,GACd,MAAM4B,EAAQC,SAASC,cAAc,OAIrC,OAHAF,EAAMG,aAAa,KAAM1C,KAAK2C,QAAU,UACxCJ,EAAMK,YAAcjC,EACpB4B,EAAMM,UAAUC,IAAI9C,KAAK+C,WAAkB,OACpCR,EAIT,iBACE,MAAMS,EAAOR,SAASC,cAAc,OAGpC,OAFAO,EAAKH,UAAUC,IAAI,kBACnBE,EAAKC,MAAMC,gBAAkBlD,KAAKmD,QAC3BH,EAIT,oBAKA,YAAYI,GACNA,GACFpD,KAAKqD,QAAQJ,MAAMC,gBAAkB,OACrC,QAAcI,IAAIC,SAASvD,KAAKqD,QAASrD,KAAK+C,WAAqB,YAEnE/C,KAAKqD,QAAQJ,MAAMC,gBAAkB,GACrC,QAAcI,IAAIE,YAAYxD,KAAKqD,QAASrD,KAAK+C,WAAqB,WAExE,QAAcU,KAAKC,SAAkC1D,KAAa,SAC9D,QAAcyD,KAAKE,MAAMC,SAAUR,IAI3C,WAAiBS,SACb,WAAiBC,KAAKC,aACtB,kBAAwBC,iBACxB,GACA;;;;;;AC9CG,MAAM,UAA0B,UAErC,YAAYC,GACV3B,MAAM2B,GAIR,OACE3B,MAAM4B,OAGN,MAAMC,EAASnE,KAAKoE,YACpBD,EAAOE,KAAKrE,KAAKsE,6BACjBH,EAAOI,wBAIT,YACE,OAAwCjC,MAAM8B,YAShD,4BAEE,IAAII,EAAW,GACf,IAAK,MAAMC,KAAezE,KAAK0E,UAC7B,GAAID,aAAuB,kBAAyB,CAElDD,EAASG,KAAK,CAACC,KAAM,QAASC,KAAMJ,EAAYK,YAKhD,IAAIC,EAAeN,EAAYO,cAGH,iBAAjBD,IACTA,EAC4D,CACxDE,OAAQF,EACRH,KAAM,aAGZJ,EAAWA,EAASU,OAAOH,GAG/B,OAAOP,EAIT,mBACExE,KAAKoE,YAAYC,KAAKrE,KAAKsE,6BAI7B,cAAca,EAAUC,GACtB,GAAIA,EAAS,CACX,MAAMC,EAASrF,KAAKoE,YACfkB,0BAA0BF,EAAQG,OAAOC,EAC9CxF,KAAKoE,YAAYqB,SAASJ,IAK9B,oBAAoBK,EAASN,GAE3B,OAAQM,GAAWA,IAAYN,EAUjC,kBAAkBzE,GAChB,MAAMgF,EAAW3F,KAAK0E,UAAUkB,KAC3BC,GAASA,aAAgB,mBACtBA,EAAKC,gBAAkBnF,IAASkF,EAAKf,WAC7C,OAAIa,GAGG,KAUT,qBAAqBhF,GACnB,MAAMyE,EAAUpF,KAAK+F,kBAAkBpF,GACvC,IAAKyE,EACH,OAEF,MAAMM,EAAU1F,KAAKgG,cAEjBhG,KAAKiG,oBAAoBP,EAASN,IACpCpF,KAAKkG,cAAcR,GAGjB1F,KAAKmG,kBAAkBT,EAASN,IAClCpF,KAAKoG,YAAYV,EAASN,GAK9B,gBAEE,MAAMjB,EAASnE,KAAKoE,YACpB,OAAID,IAAWA,EAAOkC,UACblC,EAAOmC,gBAEThE,MAAMgE,iBAKjB,MAAYzC,SAAS,CACnB;;;;;;ACrIK,MAAM,UAAgC,uBAE3C,YAAYI,EAAWE,GACrB7B,MAAM2B,EAAWE,GAOnB,iBACIoC,EACAC,EACAC,GACF,MAAMC,EAAgBpE,MAAMqE,iBACxBJ,EAAyBC,EAAmBC,GAC1CG,EAAiBH,GACnBzG,KAAK6G,kBAAkBN,GACrBO,EAAcN,GAChBxG,KAAK+G,eAAeR,GAMxB,OAJIG,IACFA,EAAcM,QACVhH,KAAKiH,QAAQC,uBAAuBN,EAAgBE,IAEnDJ;;;;;GClBJ,MAAM,UAAyB,iBAEpC,YAAYS,GACV7E,MAAM6E,GAMNnH,KAAKoH,gBAAkB,GAOvBpH,KAAKqH,aAAe,KAOpBrH,KAAKsH,wBAA0B,GAO/BtH,KAAKuH,eAAiB,GAQtBvH,KAAKwH,mBAAoB,EAEzBxH,KAAKyH,WAAWC,kBACZ,IAAI,EAAwB1H,KAAKyH,WAAYzH,OAEjDA,KAAKqG,WAAY,EASnB,oBAEE,OADgBrG,KAAK2H,gBAAgBC,aAUvC,wBACE5H,KAAKoH,gBAAkB,GACvB,MAAMS,EAAiB7H,KAAK8H,SAASC,OAAQC,GAAWA,EAAOC,WAC3DjI,KAAKkI,oBAAoBnC,kBAAkBiC,EAAOG,kBACtD,IAAK,MAAMH,KAAUH,EACfG,EAAOC,WACTjI,KAAKoH,gBAAgBzC,KAAK,CACxBhE,KAAMqH,EAAOG,gBACbC,SAAUJ,EAAOK,gBAYzB,0BAA0B1H,GACxB,IAAK,MAAM2H,KAActI,KAAKoH,gBAC5B,GAAIkB,EAAW3H,OAASA,EACtB,OAAO2H,EAAWF,SAItB,OADAG,QAAQC,KAAK,6CAA6C7H,KACnD,KAQT,gCAAgCyH,GAG9B,GAAIpI,KAAKqH,aACP,OAEF,MAAMoB,EAAiBC,KAAKC,MAAMP,EAAWpI,KAAKyH,WAAWmB,OAG7D,IAAK,IAAI7I,EAAIC,KAAKoH,gBAAgByB,OAAS,EAAG9I,GAAK,EAAGA,IAAK,CACzD,MAAM4F,EAAW3F,KAAKoH,gBAAgBrH,GACtC,GAAI0I,GAAkB9C,EAASyC,SAAS5C,EAEtC,YADAxF,KAAKkI,oBAAoBY,qBAAqBnD,EAAShF,OAU7D,SAASyH,GAGP,MAAMW,EAAU/I,KAAKyH,WAAWuB,aAChChJ,KAAKqH,aAAeqB,KAAKO,IAAIb,EAAWpI,KAAKyH,WAAWmB,MACpDG,EAAQG,aAAeH,EAAQI,YAEnCnJ,KAAKoJ,uBAQP,uBACE,IAAKpJ,KAAKqH,aACR,OAGF,MAAMgC,GAAoBrJ,KAAKyH,WAAW6B,QACpCC,EAAOvJ,KAAKqH,aAAegC,EACjC,GAAIX,KAAKc,IAAID,GAAQ,EAGnB,OAFAvJ,KAAKyH,WAAWgC,UAAUC,KAAK1J,KAAKqH,mBACpCrH,KAAKqH,aAAe,MAGtBrH,KAAKyH,WAAWgC,UAAUC,KACtBL,EAAmBE,EAAOvJ,KAAKsH,yBAEnCqC,sBAAsB3J,KAAKoJ,qBAAqBxH,KAAK5B,OAYvD,uBAAuB4G,EAAgBE,GACrC,GAAI9G,KAAKoH,gBAAgByB,OAAS,EAAG,CACnC,MAEMe,EADF5J,KAAKoH,gBAAgBpH,KAAKoH,gBAAgByB,OAAS,GACrBT,SAAS5C,EAAIxF,KAAKyH,WAAWmB,MACzDiB,EAAqBjD,EAAeI,OAAS4C,EACnD,GAAIC,EAAqB/C,EAAYE,OACnC,OAAOF,EAAYE,OAAS6C,EAGhC,OAAO,EAIT,YAAYC,GACVxH,MAAMyH,YAAYD,GACd9J,KAAKoH,iBACPpH,KAAKgK,iCAAiChK,KAAKyH,WAAW6B,SAe1D,WACE,IAAKtJ,KAAKiK,YACR,OAEF,MAAMC,EAAyBlK,KAAK2H,gBAAgBqB,aACpD,IAAKkB,EAEH,OAGFlK,KAAKmK,QAAUD,EAAuBf,WAEtC,MAAMiB,EAAYpK,KAAKqK,OAASrK,KAAKsK,cAC/BC,EACFL,EAAuBf,WAAa,EAAInJ,KAAKsK,cACjDtK,KAAKwK,mBAAmBJ,EAAWG,GAInC,IAAIE,EAAI,EAMFA,EAJFzK,KAAK2H,gBAAgB+C,iBAAmB1K,KAAK2K,iBAE3CT,EAAuBU,aACrB5K,KAAK2K,kBAAoB,kBACvBT,EAAuBU,aAKvBV,EAAuBW,UAGzB7K,KAAK2K,kBAAoB,kBACvB,EAEAT,EAAuBW,UAI3B7K,KAAK2K,kBAAoB,kBACvB,EAMAT,EAAuBW,UACvBX,EAAuBY,aAAe9K,KAAKqK,OAGnDrK,KAAK+K,YAAY/K,KAAKqK,OAAQrK,KAAKmK,QAASM,EAjClC,GAuCZ,KAAKO,GACH1I,MAAM+B,KAAK2G,GACXhL,KAAKiL,sBACLjL,KAAKuE,wBACLvE,KAAKyH,WAAWyD,iBAOlB,sBAEE,MAAMC,EAAYnL,KAAKuH,eACvBvH,KAAKuH,eAAiB,GACtB,IAAK,MAAM6D,KAAYD,EACrBC,EAASC,SAAQ,GAAO,GAO5B,aAAaC,GACX,MAAMC,EAAYD,EAASE,aAAa,QAClCC,EAAWzL,KAAKuH,eAAemE,WAAU,SAASC,GACtD,OAAOA,EAAMC,OAASL,KAExB,IAAIM,EAWJ,OATEA,EADEJ,GAAY,EACHzL,KAAKuH,eAAeuE,OAAOL,EAAU,GAAG,GAExC,MAAYM,WAAWT,EAAUtL,KAAKyH,YAE9CoE,EAASG,aAGZhM,KAAKiM,qBAAqBtH,KAAKkH,GAE1BA,EAMT,kBAEE,MAAMV,EACDnL,KAAKyH,WAAWyE,cAAa,GAClC,IAAK,MAAMP,KAASR,EACdQ,EAAM1H,WAAajE,KAAKyH,aACtBzH,KAAKwH,mBACPxH,KAAKmM,mBAAmBR,GACxB3L,KAAKoM,cAAcT,GAEnBA,EAAMN,SAAQ,GAAO,IAK3B,IAAK,MAAMgB,KAAQrM,KAAKsM,MAClBD,IACF,UAAgBE,kBAAkBF,GAClC,QAAc/I,IAAIkJ,WAAWH,IAGjCrM,KAAKsM,MAAMzD,OAAS,EAEpB,IAAK,MAAMb,KAAUhI,KAAK8H,SACxBE,EAAOqD,UAETrL,KAAK8H,SAASe,OAAS,EAGvB7I,KAAKyH,WAAWgF,0BAA0BC,QAU5C,mBAAmBf,GAEjB,GAAIA,EAAMgB,eAAiBhB,EAAMiB,cAC/B,OAAO,EAGT,IAAK,MAAMC,KAASlB,EAAMmB,UAAW,CACnC,IAAK,MAAMC,KAASF,EAAMG,SAAU,CAElC,GAAID,aAAiB,gBACnB,OAAO,EAET,GAAIA,aAAiB,iBACfA,EAAME,sBACR,OAAO,EAKb,GAAIJ,EAAMK,WAAY,CACpB,MAAMC,EACDN,EAAMK,WAAWC,cACtB,GAAIA,IAAgBnN,KAAKmM,mBAAmBgB,GAC1C,OAAO,GAIb,OAAO,EAST,qBAAqBC,GACnBpN,KAAKmM,mBAAqBiB,EAS5B,oBAAoBpB,GAClBhM,KAAKwH,kBAAoBwE,EAU3B,cAAcL,GACZ,MAAM0B,EAAK1B,EAAM2B,yBACjB3B,EAAM4B,QAAQF,EAAG5C,GAAI4C,EAAG7H,GACxBxF,KAAKuH,eAAe5C,KAAKgH;;;;;GC/YtB,MAAM,UAA0B,iBAErC,YAAY1H,GACV3B,MAAM2B,GAOR,eAAesC,GACb,MAAMqC,EAAQrC,EAA0BvG,KAAKyH,WAAWmB,MAAQ,EAC1D4E,EAAaxN,KAAKyN,gBAClBC,EAAiB1N,KAAK2N,oBACtBC,EAAgB5N,KAAK6N,kBAAiB,GACtCnD,EAAkBgD,EAAetF,SAavC,OAXIpI,KAAKyH,WAAWG,eAGd8C,GAAmB,kBACnBA,GAAmB,oBACrB8C,EAAWxG,QAAW0G,EAAe1G,OAAS4G,EAAc5G,OACnD0D,GAAmB,mBAC1BA,GAAmB,qBACrB8C,EAAWM,OAAUJ,EAAeI,MAAQF,EAAcE,QAGvD,CACL9G,OAAQwG,EAAWxG,OAAS4B,EAC5BkF,MAAON,EAAWM,MAAQlF,EAC1BmF,KAAM/N,KAAKyH,WAAW6B,QAAUV,EAChCoF,MAAOhO,KAAKyH,WAAWwG,QAAUrF,GASrC,qBACE,MAAM8E,EAAiB1N,KAAK2N,oBACtBC,EAAgB5N,KAAK6N,kBAAiB,GACtCnD,EAAkBgD,EAAetF,SACvC,IAAI0C,EAAe,EAEf9K,KAAKyH,WAAWG,cAChB8C,GAAmB,oBACrBI,EAAe4C,EAAeI,MAAQF,EAAcE,OAEtD,IAAII,EAAc,EAKlB,OAJIlO,KAAKyH,WAAWG,cAChB8C,GAAmB,mBACrBwD,EAAcR,EAAe1G,OAAS4G,EAAc5G,QAE/C,CACL+G,IAAKG,EACLF,KAAMlD,IAKZ,WAAiBjH,SAAS,WAAiBC,KAAKqK,gBAC5C,uBAAwB","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Toolbox category with styling for continuous toolbox.\n */\n\nimport * as Blockly from 'blockly/core';\n\n/** Toolbox category for continuous toolbox. */\nexport class ContinuousCategory extends Blockly.ToolboxCategory {\n  /**\n   * Constructor for ContinuousCategory which is used in ContinuousToolbox.\n   * @override\n   */\n  constructor(categoryDef, toolbox) {\n    super(categoryDef, toolbox);\n  }\n\n  /** @override */\n  createLabelDom_(name) {\n    const label = document.createElement('div');\n    label.setAttribute('id', this.getId() + '.label');\n    label.textContent = name;\n    label.classList.add(this.cssConfig_['label']);\n    return label;\n  }\n\n  /** @override */\n  createIconDom_() {\n    const icon = document.createElement('div');\n    icon.classList.add('categoryBubble');\n    icon.style.backgroundColor = this.colour_;\n    return icon;\n  }\n\n  /** @override */\n  addColourBorder_() {\n    // No-op\n  }\n\n  /** @override */\n  setSelected(isSelected) {\n    if (isSelected) {\n      this.rowDiv_.style.backgroundColor = 'gray';\n      Blockly.utils.dom.addClass(this.rowDiv_, this.cssConfig_['selected']);\n    } else {\n      this.rowDiv_.style.backgroundColor = '';\n      Blockly.utils.dom.removeClass(this.rowDiv_, this.cssConfig_['selected']);\n    }\n    Blockly.utils.aria.setState(/** @type {!Element} */ (this.htmlDiv_),\n        Blockly.utils.aria.State.SELECTED, isSelected);\n  }\n}\n\nBlockly.registry.register(\n    Blockly.registry.Type.TOOLBOX_ITEM,\n    Blockly.ToolboxCategory.registrationName,\n    ContinuousCategory,\n    true);\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Toolbox that uses a continuous scrolling flyout.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ContinuousFlyout} from './ContinuousFlyout';\n\n/**\n * Class for continuous toolbox.\n */\nexport class ContinuousToolbox extends Blockly.Toolbox {\n  /** @override */\n  constructor(workspace) {\n    super(workspace);\n  }\n\n  /** @override */\n  init() {\n    super.init();\n\n    // Populate the flyout with all blocks and show it immediately.\n    const flyout = this.getFlyout();\n    flyout.show(this.getInitialFlyoutContents_());\n    flyout.recordScrollPositions();\n  }\n\n  /** @override */\n  getFlyout() {\n    return /** @type {ContinuousFlyout} */ (super.getFlyout());\n  }\n\n  /**\n   * Gets the contents that should be shown in the flyout immediately.\n   * This includes all blocks and labels for each category of block.\n   * @return {!Blockly.utils.toolbox.FlyoutItemInfoArray} Flyout contents.\n   * @private\n   */\n  getInitialFlyoutContents_() {\n    /** @type {!Blockly.utils.toolbox.FlyoutItemInfoArray} */\n    let contents = [];\n    for (const toolboxItem of this.contents_) {\n      if (toolboxItem instanceof Blockly.ToolboxCategory) {\n        // Create a label node to go at the top of the category\n        contents.push({kind: 'LABEL', text: toolboxItem.getName()});\n        /**\n         * @type {string|Blockly.utils.toolbox.FlyoutItemInfoArray|\n         *    Blockly.utils.toolbox.FlyoutItemInfo}\n         */\n        let itemContents = toolboxItem.getContents();\n\n        // Handle custom categories (e.g. variables and functions)\n        if (typeof itemContents === 'string') {\n          itemContents =\n            /** @type {!Blockly.utils.toolbox.DynamicCategoryInfo} */ ({\n              custom: itemContents,\n              kind: 'CATEGORY',\n            });\n        }\n        contents = contents.concat(itemContents);\n      }\n    }\n    return contents;\n  }\n\n  /** @override */\n  refreshSelection() {\n    this.getFlyout().show(this.getInitialFlyoutContents_());\n  }\n\n  /** @override */\n  updateFlyout_(_oldItem, newItem) {\n    if (newItem) {\n      const target = this.getFlyout()\n          .getCategoryScrollPosition(newItem.name_).y;\n      this.getFlyout().scrollTo(target);\n    }\n  }\n\n  /** @override */\n  shouldDeselectItem_(oldItem, newItem) {\n    // Should not deselect if the same category is clicked again.\n    return (oldItem && oldItem !== newItem);\n  }\n\n  /**\n   * Gets a category by name.\n   * @param {string} name Name of category to get.\n   * @return {?Blockly.ToolboxCategory} Category, or null if not\n   *    found.\n   * @package\n   */\n  getCategoryByName(name) {\n    const category = this.contents_.find(\n        (item) => item instanceof Blockly.ToolboxCategory &&\n            item.isSelectable() && name === item.getName());\n    if (category) {\n      return /** @type {!Blockly.ToolboxCategory} */ (category);\n    }\n    return null;\n  }\n\n  /**\n   * Selects the category with the given name.\n   * Similar to setSelectedItem, but importantly, does not call updateFlyout\n   * because this is called while the flyout is being scrolled.\n   * @param {string} name Name of category to select.\n   * @package\n   */\n  selectCategoryByName(name) {\n    const newItem = this.getCategoryByName(name);\n    if (!newItem) {\n      return;\n    }\n    const oldItem = this.selectedItem_;\n\n    if (this.shouldDeselectItem_(oldItem, newItem)) {\n      this.deselectItem_(oldItem);\n    }\n\n    if (this.shouldSelectItem_(oldItem, newItem)) {\n      this.selectItem_(oldItem, newItem);\n    }\n  }\n\n  /** @override */\n  getClientRect() {\n    // If the flyout never closes, it should be the deletable area.\n    const flyout = this.getFlyout();\n    if (flyout && !flyout.autoClose) {\n      return flyout.getClientRect();\n    }\n    return super.getClientRect();\n  }\n}\n\n\nBlockly.Css.register([\n  `.categoryBubble {\n      margin: 0 auto 0.125rem;\n      border-radius: 100%;\n      border: 1px solid;\n      width: 1.25rem;\n      height: 1.25rem;\n    }\n    .blocklyTreeRow {\n      height: initial;\n      padding: 3px 0;\n    }\n    .blocklyTreeRowContentContainer {\n      display: flex;\n      flex-direction: column;\n    }\n    .blocklyTreeLabel {\n      margin: auto;\n    }`,\n]);\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\nimport * as Blockly from 'blockly/core';\n\n/** Adds additional padding to the bottom of the flyout if needed. */\nexport class ContinuousFlyoutMetrics extends Blockly.FlyoutMetricsManager {\n  /** @override */\n  constructor(workspace, flyout) {\n    super(workspace, flyout);\n  }\n  /**\n   * Adds additional padding to the bottom of the flyout if needed,\n   * in order to make it possible to scroll to the top of the last category.\n   * @override\n   */\n  getScrollMetrics(\n      getWorkspaceCoordinates = undefined,\n      cachedViewMetrics = undefined,\n      cachedContentMetrics = undefined) {\n    const scrollMetrics = super.getScrollMetrics(\n        getWorkspaceCoordinates, cachedViewMetrics, cachedContentMetrics);\n    const contentMetrics = cachedContentMetrics ||\n        this.getContentMetrics(getWorkspaceCoordinates);\n    const viewMetrics = cachedViewMetrics ||\n        this.getViewMetrics(getWorkspaceCoordinates);\n\n    if (scrollMetrics) {\n      scrollMetrics.height +=\n          this.flyout_.calculateBottomPadding(contentMetrics, viewMetrics);\n    }\n    return scrollMetrics;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Flyout that supports always-open continuous scrolling.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ContinuousToolbox} from './ContinuousToolbox';\nimport {ContinuousFlyoutMetrics} from './ContinuousMetricsFlyout';\n\n/**\n * Class for continuous flyout.\n */\nexport class ContinuousFlyout extends Blockly.VerticalFlyout {\n  /** @override */\n  constructor(workspaceOptions) {\n    super(workspaceOptions);\n\n    /**\n     * List of scroll positions for each category.\n     * @type {!Array<{name: string, position: !Object}>}\n     */\n    this.scrollPositions = [];\n\n    /**\n     * Target scroll position, used to smoothly scroll to a given category\n     * location when selected.\n     * @type {?number}\n     */\n    this.scrollTarget = null;\n\n    /**\n     * The percentage of the distance to the scrollTarget that should be\n     * scrolled at a time. Lower values will produce a smoother, slower scroll.\n     * @type {number}\n     */\n    this.scrollAnimationFraction = 0.3;\n\n    /**\n     * A list of blocks that can be recycled.\n     * @type {!Array.<!Blockly.BlockSvg>}\n     * @private\n     */\n    this.recycleBlocks_ = [];\n\n    /**\n     * Whether to recycle blocks when refreshing the flyout. When false, do not\n     * allow anything to be recycled. The default is to recycle.\n     * @type {boolean}\n     * @private\n     */\n    this.recyclingEnabled_ = true;\n\n    this.workspace_.setMetricsManager(\n        new ContinuousFlyoutMetrics(this.workspace_, this));\n\n    this.autoClose = false;\n  }\n\n  /**\n   * Gets parent toolbox.\n   * Since we registered the ContinuousToolbox, we know that's its type.\n   * @return {!ContinuousToolbox} Toolbox that owns this flyout.\n   * @private\n   */\n  getParentToolbox_() {\n    const toolbox = this.targetWorkspace.getToolbox();\n    return /** @type {!ContinuousToolbox} */ (toolbox);\n  }\n\n  /**\n   * Records scroll position for each category in the toolbox.\n   * The scroll position is determined by the coordinates of each category's\n   * label after the entire flyout has been rendered.\n   * @package\n   */\n  recordScrollPositions() {\n    this.scrollPositions = [];\n    const categoryLabels = this.buttons_.filter((button) => button.isLabel() &&\n        this.getParentToolbox_().getCategoryByName(button.getButtonText()));\n    for (const button of categoryLabels) {\n      if (button.isLabel()) {\n        this.scrollPositions.push({\n          name: button.getButtonText(),\n          position: button.getPosition(),\n        });\n      }\n    }\n  }\n\n  /**\n   * Returns the scroll position for the given category name.\n   * @param {string} name Category name.\n   * @return {?Object} Scroll position for given category, or null if not found.\n   * @package\n   */\n  getCategoryScrollPosition(name) {\n    for (const scrollInfo of this.scrollPositions) {\n      if (scrollInfo.name === name) {\n        return scrollInfo.position;\n      }\n    }\n    console.warn(`Scroll position not recorded for category ${name}`);\n    return null;\n  }\n\n  /**\n   * Selects an item in the toolbox based on the scroll position of the flyout.\n   * @param {number} position Current scroll position of the workspace.\n   * @private\n   */\n  selectCategoryByScrollPosition_(position) {\n    // If we are currently auto-scrolling, due to selecting a category by\n    // clicking on it, do not update the category selection.\n    if (this.scrollTarget) {\n      return;\n    }\n    const scaledPosition = Math.round(position / this.workspace_.scale);\n    // Traverse the array of scroll positions in reverse, so we can select the\n    // furthest category that the scroll position is beyond.\n    for (let i = this.scrollPositions.length - 1; i >= 0; i--) {\n      const category = this.scrollPositions[i];\n      if (scaledPosition >= category.position.y) {\n        this.getParentToolbox_().selectCategoryByName(category.name);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Scrolls flyout to given position.\n   * @param {number} position The x coordinate to scroll to.\n   */\n  scrollTo(position) {\n    // Set the scroll target to either the scaled position or the lowest\n    // possible scroll point, whichever is smaller.\n    const metrics = this.workspace_.getMetrics();\n    this.scrollTarget = Math.min(position * this.workspace_.scale,\n        metrics.scrollHeight - metrics.viewHeight);\n\n    this.stepScrollAnimation_();\n  }\n\n  /**\n   * Step the scrolling animation by scrolling a fraction of the way to\n   * a scroll target, and request the next frame if necessary.\n   * @private\n   */\n  stepScrollAnimation_() {\n    if (!this.scrollTarget) {\n      return;\n    }\n\n    const currentScrollPos = -this.workspace_.scrollY;\n    const diff = this.scrollTarget - currentScrollPos;\n    if (Math.abs(diff) < 1) {\n      this.workspace_.scrollbar.setY(this.scrollTarget);\n      this.scrollTarget = null;\n      return;\n    }\n    this.workspace_.scrollbar.setY(\n        currentScrollPos + diff * this.scrollAnimationFraction);\n\n    requestAnimationFrame(this.stepScrollAnimation_.bind(this));\n  }\n\n  /**\n   * Add additional padding to the bottom of the flyout if needed,\n   * in order to make it possible to scroll to the top of the last category.\n   * @param {!Blockly.MetricsManager.ContainerRegion} contentMetrics Content\n   *    metrics for the flyout.\n   * @param {!Blockly.MetricsManager.ContainerRegion} viewMetrics View metrics\n   *    for the flyout.\n   * @return {number} Additional bottom padding.\n   */\n  calculateBottomPadding(contentMetrics, viewMetrics) {\n    if (this.scrollPositions.length > 0) {\n      const lastCategory =\n          this.scrollPositions[this.scrollPositions.length - 1];\n      const lastPosition = lastCategory.position.y * this.workspace_.scale;\n      const lastCategoryHeight = contentMetrics.height - lastPosition;\n      if (lastCategoryHeight < viewMetrics.height) {\n        return viewMetrics.height - lastCategoryHeight;\n      }\n    }\n    return 0;\n  }\n\n  /** @override */\n  setMetrics_(xyRatio) {\n    super.setMetrics_(xyRatio);\n    if (this.scrollPositions) {\n      this.selectCategoryByScrollPosition_(-this.workspace_.scrollY);\n    }\n  }\n\n  /**\n   * Overrides the position function solely to change the x coord in RTL mode.\n   * The base function allows the workspace to go \"under\" the flyout, so\n   * to calculate the left edge of the flyout in RTL you would just subtract\n   * the flyout width from the total viewWidth to get x. However, in our\n   * flyout, the workspace already starts at the left edge of the flyout, so\n   * we don't need to subtract the flyout width again.\n   * Ideally there would be a smaller method for us to override instead,\n   * but for now we copy/paste this method and make our fixes.\n   * @override\n   */\n  position() {\n    if (!this.isVisible()) {\n      return;\n    }\n    const targetWorkspaceMetrics = this.targetWorkspace.getMetrics();\n    if (!targetWorkspaceMetrics) {\n      // Hidden components will return null.\n      return;\n    }\n    // Record the height for Blockly.Flyout.getMetrics_\n    this.height_ = targetWorkspaceMetrics.viewHeight;\n\n    const edgeWidth = this.width_ - this.CORNER_RADIUS;\n    const edgeHeight =\n        targetWorkspaceMetrics.viewHeight - 2 * this.CORNER_RADIUS;\n    this.setBackgroundPath_(edgeWidth, edgeHeight);\n\n    // Y is always 0 since this is a vertical flyout.\n    const y = 0;\n    let x = 0;\n    // If this flyout is the toolbox flyout.\n    if (this.targetWorkspace.toolboxPosition == this.toolboxPosition_) {\n      // If there is a category toolbox.\n      if (targetWorkspaceMetrics.toolboxWidth) {\n        if (this.toolboxPosition_ == Blockly.TOOLBOX_AT_LEFT) {\n          x = targetWorkspaceMetrics.toolboxWidth;\n        } else {\n          // TODO(https://github.com/google/blockly/issues/4396): Use a better\n          // API to adjust this value.\n          // This is the only line that changed from the original.\n          x = targetWorkspaceMetrics.viewWidth;\n        }\n      } else {\n        if (this.toolboxPosition_ == Blockly.TOOLBOX_AT_LEFT) {\n          x = 0;\n        } else {\n          x = targetWorkspaceMetrics.viewWidth;\n        }\n      }\n    } else {\n      if (this.toolboxPosition_ == Blockly.TOOLBOX_AT_LEFT) {\n        x = 0;\n      } else {\n        // Because the anchor point of the flyout is on the left, but we want\n        // to align the right edge of the flyout with the right edge of the\n        // blocklyDiv, we calculate the full width of the div minus the width\n        // of the flyout.\n        x = targetWorkspaceMetrics.viewWidth +\n            targetWorkspaceMetrics.absoluteLeft - this.width_;\n      }\n    }\n    this.positionAt_(this.width_, this.height_, x, y);\n  }\n\n  /**\n   * @override\n   */\n  show(flyoutDef) {\n    super.show(flyoutDef);\n    this.emptyRecycleBlocks_();\n    this.recordScrollPositions();\n    this.workspace_.resizeContents();\n  }\n\n  /**\n   * Empty out the recycled blocks, properly destroying everything.\n   * @protected\n   */\n  emptyRecycleBlocks_() {\n    // Clean out the old recycle bin.\n    const oldBlocks = this.recycleBlocks_;\n    this.recycleBlocks_ = [];\n    for (const oldBlock of oldBlocks) {\n      oldBlock.dispose(false, false);\n    }\n  }\n\n  /**\n   * @override\n   */\n  createBlock_(blockXml) {\n    const blockType = blockXml.getAttribute('type');\n    const blockIdx = this.recycleBlocks_.findIndex(function(block) {\n      return block.type === blockType;\n    });\n    let curBlock;\n    if (blockIdx > -1) {\n      curBlock = this.recycleBlocks_.splice(blockIdx, 1)[0];\n    } else {\n      curBlock = Blockly.Xml.domToBlock(blockXml, this.workspace_);\n    }\n    if (!curBlock.isEnabled()) {\n      // Record blocks that were initially disabled.\n      // Do not enable these blocks as a result of capacity filtering.\n      this.permanentlyDisabled_.push(curBlock);\n    }\n    return curBlock;\n  }\n\n  /**\n   * @override\n   */\n  clearOldBlocks_() {\n    // Delete any blocks from a previous showing.\n    const oldBlocks = /** @type {!Array<!Blockly.BlockSvg>} */\n        (this.workspace_.getTopBlocks(false));\n    for (const block of oldBlocks) {\n      if (block.workspace == this.workspace_) {\n        if (this.recyclingEnabled_ &&\n          this.blockIsRecyclable_(block)) {\n          this.recycleBlock_(block);\n        } else {\n          block.dispose(false, false);\n        }\n      }\n    }\n    // Delete any mats from a previous showing.\n    for (const rect of this.mats_) {\n      if (rect) {\n        Blockly.Tooltip.unbindMouseEvents(rect);\n        Blockly.utils.dom.removeNode(rect);\n      }\n    }\n    this.mats_.length = 0;\n    // Delete any buttons from a previous showing.\n    for (const button of this.buttons_) {\n      button.dispose();\n    }\n    this.buttons_.length = 0;\n\n    // Clear potential variables from the previous showing.\n    this.workspace_.getPotentialVariableMap().clear();\n  }\n\n  /**\n   * Determine if this block can be recycled in the flyout.  Blocks that have no\n   * variables and are not dynamic shadows can be recycled.\n   * @param {!Blockly.BlockSvg} block The block to attempt to recycle.\n   * @return {boolean} True if the block can be recycled.\n   * @protected\n   */\n  blockIsRecyclable_(block) {\n    // If the block needs to parse mutations, never recycle.\n    if (block.mutationToDom && block.domToMutation) {\n      return false;\n    }\n\n    for (const input of block.inputList) {\n      for (const field of input.fieldRow) {\n        // No variables.\n        if (field instanceof Blockly.FieldVariable) {\n          return false;\n        }\n        if (field instanceof Blockly.FieldDropdown) {\n          if (field.isOptionListDynamic()) {\n            return false;\n          }\n        }\n      }\n      // Check children.\n      if (input.connection) {\n        const targetBlock = /** @type {Blockly.BlockSvg} */\n            (input.connection.targetBlock());\n        if (targetBlock && !this.blockIsRecyclable_(targetBlock)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Sets the function used to determine whether a block is recyclable.\n   * @param {function(!Blockly.BlockSvg):boolean} func The function used to\n   *     determine if a block is recyclable.\n   * @public\n   */\n  setBlockIsRecyclable(func) {\n    this.blockIsRecyclable_ = func;\n  }\n\n  /**\n   * Set whether the flyout can recycle blocks.\n   * @param {boolean} isEnabled True to allow blocks to be recycled, false\n   *     otherwise.\n   * @public\n   */\n  setRecyclingEnabled(isEnabled) {\n    this.recyclingEnabled_ = isEnabled;\n  }\n\n  /**\n   * Puts a previously created block into the recycle bin and moves it to the\n   * top of the workspace. Used during large workspace swaps to limit the number\n   * of new DOM elements we need to create.\n   * @param {!Blockly.BlockSvg} block The block to recycle.\n   * @protected\n   */\n  recycleBlock_(block) {\n    const xy = block.getRelativeToSurfaceXY();\n    block.moveBy(-xy.x, -xy.y);\n    this.recycleBlocks_.push(block);\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Overrides metrics to exclude the flyout from the viewport.\n */\n\nimport * as Blockly from 'blockly/core';\n\n/** Computes metrics for a toolbox with an always open flyout. */\nexport class ContinuousMetrics extends Blockly.MetricsManager {\n  /** @override */\n  constructor(workspace) {\n    super(workspace);\n  }\n  /**\n   * Computes the viewport size to not include the toolbox and the flyout.\n   * The default viewport includes the flyout.\n   * @override\n   */\n  getViewMetrics(getWorkspaceCoordinates = undefined) {\n    const scale = getWorkspaceCoordinates ? this.workspace_.scale : 1;\n    const svgMetrics = this.getSvgMetrics();\n    const toolboxMetrics = this.getToolboxMetrics();\n    const flyoutMetrics = this.getFlyoutMetrics(false);\n    const toolboxPosition = toolboxMetrics.position;\n\n    if (this.workspace_.getToolbox()) {\n      // Note: Not actually supported at this time due to ContinunousToolbox\n      // only supporting a vertical flyout. But included for completeness.\n      if (toolboxPosition == Blockly.TOOLBOX_AT_TOP ||\n          toolboxPosition == Blockly.TOOLBOX_AT_BOTTOM) {\n        svgMetrics.height -= (toolboxMetrics.height + flyoutMetrics.height);\n      } else if (toolboxPosition == Blockly.TOOLBOX_AT_LEFT ||\n          toolboxPosition == Blockly.TOOLBOX_AT_RIGHT) {\n        svgMetrics.width -= (toolboxMetrics.width + flyoutMetrics.width);\n      }\n    }\n    return {\n      height: svgMetrics.height / scale,\n      width: svgMetrics.width / scale,\n      top: -this.workspace_.scrollY / scale,\n      left: -this.workspace_.scrollX / scale,\n    };\n  }\n\n  /**\n   * Moves the absoluteLeft and absoluteTop so they no longer include the\n   * flyout.\n   * @override\n   */\n  getAbsoluteMetrics() {\n    const toolboxMetrics = this.getToolboxMetrics();\n    const flyoutMetrics = this.getFlyoutMetrics(false);\n    const toolboxPosition = toolboxMetrics.position;\n    let absoluteLeft = 0;\n\n    if (this.workspace_.getToolbox() &&\n        toolboxPosition == Blockly.TOOLBOX_AT_LEFT) {\n      absoluteLeft = toolboxMetrics.width + flyoutMetrics.width;\n    }\n    let absoluteTop = 0;\n    if (this.workspace_.getToolbox() &&\n        toolboxPosition == Blockly.TOOLBOX_AT_TOP) {\n      absoluteTop = toolboxMetrics.height + flyoutMetrics.height;\n    }\n    return {\n      top: absoluteTop,\n      left: absoluteLeft,\n    };\n  }\n}\n\nBlockly.registry.register(Blockly.registry.Type.METRICS_MANAGER,\n    'CustomMetricsManager', ContinuousMetrics);\n"],"sourceRoot":""}